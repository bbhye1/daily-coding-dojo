# 문제1
## 공주구하기(큐)

### 원하는 것
공주를 구하러 갈 왕자의 번호  

### 내가 아는 것
- 입력값: 왕자의 수 n, 특정 숫자 k

### 조건
1. 5 <= n <=1,000
2. 2 <= k <= 9

### 계획
숫자대로 1부터 n까지 들어있는 배열을 만든다. 
k번째까지 shift()와 push()를 반복하는데 k번일때는 shift()만 한다. 
배열의 길이가 1이 될때 까지 반복한다.
마지막 남은 수가 왕자의 번호가 된다. 

### 반성 
--

# 문제2
## 응급실

### 원하는 것
m번째 환자가 진료받는 순서 

### 내가 아는 것
- 입력값: 대기목록 순서의 환자 위험도 배열 rank, 원하는 환자 시작 순서 m

### 조건
1. 5 <= 환자 수 <=100
2. 0 <= m <= 9
3. 50 <= 위험도 <= 100
4. 위험도는 더 높을 수록 더 위험하다. 

### 계획
rank를 고유하게 [수, 인덱스]로 변환한다. 
하나씩 shift()를 한다. 나머지 배열에 그것보다 큰 수가 있으면(max) 다시 push해주고 아니면 
새 결과배열에 push한다.
rank에 아무것도 남지 않을 때까지 반복한다. 
결과배열의 원소중 [1]번째 인덱스가 몇번째인지 인덱스를 구한다. 

### 반성 
나는 새 배열을 만들어서 그 배열중에서 인덱스가 같은 것을 찾는 프로세스로 작성했는데 사실 순서는 그렇게 따로 구하지 않고 한번에 count를 해줄 수 있었던 것이다. 
불필요한 로직이 들어갔다고도 볼 수 있다. 기왕이면 한번에 처리할 수 있는 로직을 강구해보자. 

# 문제3
## 교육과정 설계

### 원하는 것
수업설계가 맞으면 "yes" 아니면 "no"로 변환된 배열 

### 내가 아는 것
- 입력값: 필수과목순서 문자열 n, 현수가 짠 수업설계 배열 m.

### 조건
1. 1 <= m의 길이 <=10
2. m의 모든 요소는 영문 대문자이다.
3. m 요소의 길이는 30이하이다.
4. 같은 과목을 여러번 이수해도 된다. 

### 계획
n도 배열로 만든다. 
m을 순회한다. 
m의 각 요소를 배열로 만든다. 
새 결과 배열을 선언한다. 
shift()한 요소가 n배열에 포함되고 새 결과 배열 그 요소가 없다면 push해준다. 
새 결과 배열을 문자열로 합치고 n이 포함되어있는지 확인한다. 
  
### 반성 
2번 문제와 마찬가지로 yes, no반환을 바로 해 줄 수 있는데 궅이 새 배열을 만들어서 결과를 다시 수정하는 불필요한 로직이 들어갔다. 불필요한 로직이 들어간 부분을 제외하고 
같은 강의를 여러번 들었을 때의 순서확인 문제를 어떻게 해주어야하나 고민했는데 기준 값 배열을 shift해서 원소를 없애주어 나머지에서 중복이 나오더라도 문제가 없도록 해결하는 방안이 있어서 그것을 배웠다. 



