# 문제1 
## 회문 문자열 검사

### 원하는 것
회문 문자열일 경우 yes 아닐경우 no 반환

### 내가 아는 것
입력값: 문자열, 회문 문자열: 앞에서 읽을 때나 뒤에서 읽을 때나 같은 문자열

### 조건
각 단어의 길이는 100을 넘지 않는다.
대소문자 구분을 하지 않는다. 

### 계획
원래문자에 모두 대문자로 변환한것과 변환한 문자열을 각각 쪼개서(split) 뒤집은 다음 합친문자가 처음 문자랑 같다면 yes 아니라면 no 

### 반성 
--

# 문제2
## 숫자만 추출

### 원하는 것
문자열에서 숫자만 추출하여 순서대로 자연수를 만들고 그 자연수의 약수 개수와 함께 출력. 

### 내가 아는 것
입력값: 숫자와 문자열이 섞여있는 문자열

### 조건
추출하여 만들어지는 자연수는 100,000,000을 넘지 않습니다
문자열의 길이는 50을 넘지 않습니다.

### 계획
split으로 문자를 쪼개고 모두 숫자로 변환하여 NaN가 아닌것만 골라내어 새로 숫자를 만든다. 그리고 그 수의 약수를 구한다. 

### 반성 
--

# 문제3
## 카드 역배출

### 원하는 것
1부터 20까지 오름차순으로 놓인 카드들에 대해, 입력으로 주어진 10개의 구간 순서대로 뒤집는 작업을 했을 때 마지막 카드들의 배치

### 내가 아는 것
입력값: 뒤집기 구간이 10개 들어있는 배열 

### 조건
 [a, b] 1 ≤ a ≤ b ≤ 20
 첫번째 칸의 인덱스가 1.

### 계획
다른방법 없다. splice로 문제 순서대로 진행해보자.

### 반성 
--

# 문제4
## 두 리스트 합치기

### 원하는 것
두 리스트를 오름차순으로 합쳐 반환

### 내가 아는 것
입력값: 오름차순으로 정렬이 된 두 리스트

### 조건
1. 각 리스트의 크기: 1<=N<=100
2. 각 리스트의 원소는 int형 변수의 크기를 넘지 않습니다.

### 계획
concat으로 합치고 정렬해주자. 

### 반성 
sort를 해주면 시간복잡도가 올라간다! 정렬된 두 리스트라면 하나를 기준으로 잡고 퀵정렬해주는 것이 좋다. 

# 문제5
## 수들의 합

### 원하는 것
수열 a의 i번째 수부터 j번째 수까지의 합이 m되는 경우의 수를 구하기

### 내가 아는 것
입력값: 합 m, 배열 a

### 조건
1. a의 길이(1≤ a.length ≤10,000)
2. M (1≤ M ≤300,000,000)
3. a의 각각의 요소는 30,000을 넘지 않는 자연수

### 계획
a의 각각의 요소의 길이만큼 반복한다. 그안에 바깥 반복문의 두번째부터 시작해서 slice와 reduce로 합을 구해준다. 
그중 숫자가 3이 나올때만 answer에 1씩 추가하고 값을 반환해준다.  

### 반성
내 풀이가 틀린건 아니지만 전체를 반복하고 또 반복하기 때문에 복잡도가 높아져 속도가 느리다. 그렇게 순환하지말고 시작점과 끝점을 한칸씩 올려주고 내려준다는 점을 고려해서 문제를 풀어보자. 
