# 문제1
## 이분검색

### 원하는 것
오름차순 된 numbers 중 m이 몇번째인지

### 내가 아는 것
입력값: 자연수로 이루어진 배열 numbers

### 조건
1. 중복값은 없다. 
2. numbers의 요소는 3이상 1,000,000 이하

### 계획
numbers를 오름차순으로 소팅하고 findIndex로 인덱스 찾기 

### 반성 
이분 검색이 주제인데 그냥 findIndex로 풀었다. 간단한 매서드를 이용할 수 있더라도 문제의 원리를 파악하고 풀어보자. (하지만 findIndex도 부족함없이 빠르다.) 

# 문제2
## 랜선자르기(결정알고리즘)

### 원하는 것
만들 수 있는 최대 랜선의 길이 

### 내가 아는 것
입력값: 이미 가지고 있는 랜선 배열 numbers, 필요한 랜선 개수 n

### 조건
1. 자른 랜선은 붙일 수 없다. 
2. n개보다 많이 만드는 것도 N개를 만드는 것에 포함된다.
3. numbers의 요소의 개수는 1이상 10,000이하
4. numbers의 요소는 2의 31승 -1 이하의 자연수
4. n은 1이상 1,000,000이하의 정수

### 계획
numbers 배열 중 가장 큰 수를 반을 나눈 숫자를 기준으로 삼는다.
while문으로 반복하여 numbers의 각 수를 기준숫자로 나눈 몫의 합들이 n보다 클경우 
원래 기준 숫자에 기준숫자 /2 의 몫을 추가해서 바꿔주고 작다면 기준숫자 /2 의 몫을 기준숫자로 바꾼다. 몫들의 합이 n과 같다면 그것이 정답이 된다.  

### 반성 
시작과 끝수를 계속 조절해서 최대값을 구해나가는 법을 배웠다. 

# 문제3
## 뮤직비디오(결정알고리즘)

### 원하는 것
DVD의 최소 용량 크기

### 내가 아는 것
입력값: DVD개수 m, 라이브에서 부른 곡의 길이(자연수 분단위)들이 담긴 배열 timelines,

### 조건
1. 곡의 순서는 유지되어야 한다. 사이에 빠질 수 없다.
2. 한 노래를 두개로 쪼개면 안된다.

### 계획
곡들의 길이를 다 합해서 DVD 개수로 나눈다. 
나눈 곡들에 뒤에서부터 최대한으로 들어가도록 맞춘다. 
그 다음 숫자가 들어가지 않으면 중단하고 다음 배열로 넘어가기. 

### 반성 
처음엔  DVD개수로 나누어 그걸 기준으로 구분했는데 그것이 아니라 이분 탐색으로 풀어야 했다. 이분 탐색에 익숙해지기로 하자. 그리고 반례를 항상 생각하자. 개수가 최소한 1개는 되어야 한다는 점을 잊으면 안된다. 


