# 문제1
## 마굿간(결정 알고리즘)

### 원하는 것
가장 가까운 두 말의 최대 거리

### 내가 아는 것
입력값: 자연수로 이루어진 배열 numbers

### 조건
1. 2 <= c <= numbers.length 
2. numbers의 요소는 3이상 200,000 이하
3. 0 <= 마굿간좌표 <=1,000,000,000


# 문제2
## 회의실 배정(그리디)

### 원하는 것
회의실을 사용할 수 있는 최대수의 회의

### 내가 아는 것
입력값: 회의 시간이 들어있는 배열 meetings [[시작시간, 끝시간], ...]

### 조건
1. 회의의 수는 1이상 100,000 이하
2. 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다.

### 계획
각 배열을 순환해서 새 배열을 만든다.(재귀로 하면 좋겠지만 효율이 나올까?) 새 배열에 마지막 인덱스의 [1]가 현재 요소의 [0] 보다 작거나 같을 때 요소를 새 배열에 추가해준다. 
새 배열의 총 개수가 answer보다 크다면 answer를 새배열의 길이로 변경해준다. 

### 반성 
재귀도 필요없는 간단한 문제였다. 제일 중점적으로 생각해야 하는 것은 끝나는 시간이 일찍이어야 많은 회의 수를 할 수 있다는 것이다. 끝나는 수를 기준으로 정렬해놓고 하나씩 순회를 돌며 추가하면 최댓값을 얻을 수 있다. 그리디 문제는 어떤 기준으로 정렬해야 하는지가 중요한 것 같다. 

# 문제3
## 씨름 선수(그리디)

### 원하는 것
씨름 선수로 뽑히는 최대인원의 수 

### 내가 아는 것
입력값: 지원자의 정보가 담긴 배열 [[키, 몸무게], ...]

### 조건
1.  키와 몸무게 중 적어도 하나는 크거나, 무거워야한다.
2. 지원자의 수는 5 이상 50 이하이다.

### 계획
키로 정렬 후 키 최고 선수를 뽑고 그 선수의 몸무게 이하의 선수를 걸러낸다. 그다음 몸무게로 정렬 후 최고몸무게의 키보다 작은 선수를 제거한다.

=> 결국 계획한 대로 해결 못하고 fiter로 걸러서 풀었다. 

### 반성 

# 문제4
## 창고정리

### 원하는 것
m회의 높이 조정을 한 후 가장 높은 곳과 가장 낮은 곳의 차이 

### 내가 아는 것
입력값: 박스의 높이들의 배열 heights, 높이 조정 횟수 m

### 조건
1. 1<=M<=1,000
2. heights의 길이는 1 이상 100 이하이다.
3. 높이 조정: 가장 높은 곳에 상자를 가장 낮은 곳으로 이동하는 것
4. 가장 높은 곳이나 가장 낮은 곳이 여러곳이면 그 중 아무거나 선택하면 된다.

### 계획
각 요소들 중 max와 min값을 구한다. => indexOf로 인덱스 찾아서 -1, +1 을 해준다. m번 반복후 
max값과 min값 구해서 차이를 출력한다.  

### 반성 
max, min을 쓰는 방법과 sorting을 계속 해주는 방법 두가지로 해봤는데 생각 외로 sorting으로 푸는게 속도가 조금 더 빨랐다. 인강에서도 그냥 계속 소팅하라고 알려줬다. 소팅이 의외로 제일 빠른 방법일 수 있다는 걸 명심해야겠다. 