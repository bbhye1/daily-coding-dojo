# 문제1
## 곶감(모래시계)

### 원하는 것
M개의 회전명령을 실행하고 난 후 모래시계 모양의 영역에 있는 감의 총 개수 

### 내가 아는 것
- 입력값: n * n 격자 배열, 각각 격자에 곶감의 수가 들어있다, 회전 명령 배열(각 요소: [행번호, 방향, 회전하는 격자수])
- 모래시계 모양의 격자판만 수확

### 조건
1. 3 <= N(홀수) <= 20
2. 1 <= 회전명령의 개수 <=10
3. 격자안의 감의 개수는 100을 넘지 않는다.
4. 두 번째 수는 방향인데 0이면 왼쪽, 1이면 오른쪽

### 계획
행: i, 열 j 

회전명령을 실행한다. 

중간위치의 숫자를 구한다. 
시작, 끝위치를 사작과 끝위치로 할당해서 시작한다. 

i반복 & j반복하며 j가 시작보다 작거나 같고 끝보다 크거나 같을때의 array[i][j] 값을 구한다.
구한값을 answer에 더해주고 answer를 반환한다. 

### 반성 
--

# 문제2
## 봉우리

### 원하는 것
봉우리의 개수 

### 내가 아는 것
- 입력값: n * n 격자 배열: 각각의 높이가 들어있다.
-격자의 가장자리는 0으로 초기화되어있다. 

### 조건
1. 자신의 상하좌우 숫자보다 큰 숫자는 봉우리
2. 1 <= N <= 50
3. 각 자연수는 100 이하.

### 계획
행: i, 열 j 

중첩 for문으로 반복한다. 
numbers[i-11][j] 상
numbers[i+1][j] 히
numbers[i][j-1] 좌
numbers[i][j+1] 우
가 numbers[i][j] 보다 작다면 봉우리 count + 1


### 반성 
먼저 0으로 주변을 채워준다면 조건문 연산이 확 줄게 된다. 미리 세팅하는 것이 시간계산에 빨라 질 수 있으니 먼저 배열을 다르게 조정해서 순회하는 것도 고려하면서 문제를 풀자. 

# 문제2
## 스도쿠 검사

### 원하는 것
스도쿠가 정확하게 풀리면 'YES' 아니면 'NO' 

### 내가 아는 것
- 입력값: 9 * 9 격자 배열.

### 조건
1. 각 행에 1부터 9까지의 숫자가 중복 없어야 통과,
2. 각 열에 1부터 9까지의 숫자가 중복 없어야 통과, 
3. 각 3×3짜리 사각형에 1부터 9까지의 숫자가 중복 없어야 통과.

### 계획
행: i, 열 j 

중첩 for문으로 순환한다.

가로: Set,
세로: Set,

numbers[i][j] 가로에 넣기, 
numbers[j][i] 세로에 넣기,

if(Set.size !== 9) No 가로세로를 확인. 

사각형 : Set
i가 0, 3, 6 j가 0, 3, 6일 때  주변 아홉개를 순환해서 배열에 넣는다. 
if(Set.size !== 9) No 가로세로를 확인. 

### 반성 
--

# 문제4
## 격자판 회문수

### 원하는 것
가로방향 또는 세로방향 5자리 회문수의 개수

### 내가 아는 것
- 입력값: 7 * 7 격자 배열, 각각 격자에 1~9까지의 자연수가 들어있다.
- 모래시계 모양의 격자판만 수확

### 조건
1. 회문수란 121과 같이 앞에서부터 읽으나 뒤에서부터 읽으나 같은 수
2. 구부러진 경우는 회문수로 간주하지 않는다.

### 계획
행: i, 열 j 

중첩실행한다. for문 *3 

가로 값: array[i][j] 값을 구한다. i++ => 5개를 3번까지만 
세로값: array[j][i] 값을 구한다. j++ => 5개를 3번까지만 

구한 배열이 reverse와 같다면 answer + 1.

answer를 반환한다. 

### 반성 
--
