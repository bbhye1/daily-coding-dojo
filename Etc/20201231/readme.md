# 문제1 
## 정다면체

### 원하는 것
두 개의 정 N면체와 정 M면체의 두 개의 주사위를 던져서 나올 수 있는 눈의 합 중 가장 확률이 높은 숫자들의 인덱스배열

### 내가 아는 것
입력값: 자연수 N과 M, N과 M은 4, 6, 8, 12, 20 중의 하나

### 조건
정답이 여러개일 경우 오름차순으로 반환

### 계획
각 합 숫자를 key로 하는 객체를 만들어 동일한 개수의 value를 가진 key들의 인덱스를을 구한다.

### 반성 
숫자를 key로 하는 어리석은 짓을 해서 문자가된 숫자 key들을 다시 숫자로 변환시켜주는 번거로운 작업을 거쳐야 했다. 
새로 푼 풀이에서는 아예 index에 초점을 맞춰서 배열을 만들어 값을 구했다.순환이 적어지니 속도도 준다. 그리 길지 않은 인덱스들이라면 배열매서드가 적합하다는 걸 기억하자. 

# 문제2 
## 자릿수의 합

### 원하는 것
각 자연수의 자릿수의 합을 구하고, 그 합이 최대인 자연수를 출력

### 내가 아는 것
입력값: 자연수 들의 배열 numbers

### 조건
각 자연수의 크기는 10,000,000를 넘지 않는다

### 계획
각 자연수 개수만큼 순환한다(forEach), 자연수를 문자열 배열로 만들고 뒤집어 준다음 다시 숫자로 만들어 큰 수를 비교하고 인덱스를 구한다. 구해진 인덱스로 원래 배열에서 값을 구한다. 

### 반성 
가장 큰 수를 순회로 구하면서 인덱스를 구해줄 수도 있고 가장 큰 수를 구해서(Math.max()) 인덱스를 findIndex()로 구하고 값을 구해주는 것과 어떤차이가 있을지 모르겠다. 숫자가 많아지면 속도면에서 차이가 있을수도 있을것같다. 

# 문제3 
## 소수의 개수

### 원하는 것
1부터 N까지의 소수의 개수

### 내가 아는 것
입력값: 자연수 N

### 조건
2 <= N <= 200,000

### 계획
기본 결과배열에 2를 넣어주고 3부터 순회를 시작한다. 각 수에서 1을 제외한 다른 숫자로 나눈 나머지가 0이라면 바로 순회를 멈추고 그 수를 결과배열에 넣어준다. 이런식으로 모든 수를 순화한다. 

### 반성 
나름 최소한의 순회로만 짜려고 했었고 또 작은 수를 비교했을 때는 속도차이가 별로 없어서 몰랐는데 에라토스테네스 체 방식을 사용하니 200000 숫자를 넣어봤을때 64초와 9초로 속도차이가 어마어마하게 났다. 소수는 에라토스테네스를 사용해야겠다.  

# 문제4
## 뒤집은 소수

### 원하는 것
자연수 배열에서 각 자연수를 뒤집은 수 중 소수만 리턴하는 배열 

### 내가 아는 것
입력값: 자연수 배열 numbers

### 조건
- 3 <= 자연수의 개수 <= 100
각 자연수 > 100,000

### 계획
각 숫자만큼 순회를 돌면서 숫자들을 거꾸로 뒤집어준다. (split, reverse, join)

순회 안에서 i = 2부터 시작해서 나눠지는 수가 있으면 멈추고 아니면 소수이므로 정답배열에 넣어준다.

### 반성 
처음에 소수를 구할 때 그냥 전체 범위로 for문을 돌았는데 소수 확인할때는 그 절반만 돌아도 된다는 걸 알았다. 소수인지 확인할 때는 절반만큼만 반복하도록 하자. 

# 문제5 
## 주사위게임

### 원하는 것
가장 많은 상금을 받은 사람의 상금

### 내가 아는 것
입력값: 한사람당 주사위를 3번던져서 나온 결과들을 나열한 배열

### 조건
1. 같은 눈이 3개가 나오면 10,000원+(같은 눈)*1,000원의 상금을 받게 된다.
2.  같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)*100원의 상금을 받게 된다.
3.  모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)*100원의 상금을 받게 된다. 

4. 참여하는 사람의 수 는 2이상 1000이하

### 계획
결과 배열을 빈배열로 만들어주고 각 배열의 요소를 순회해서 map객체를 만들어준다. map객체 사이즈 별로 각각 점수를 걔싼해서 결과배열에 넣어준다. 

### 반성 
Map을 사용해보고자 해서 그것으로 풀었는데 전혀~ 필요가 없는 문제였다. 그냥 조건문으로 더 간단하고 심플하게 풀 수 있었는데 괜히 더 복잡하게 풀었다.  다양한 자료형을 쓰는 연습도 좋지만 언제나 더 효율적인 방법이 없는지 살펴보기가 우선되어야 한다. 

# 문제6
## 점수계산

### 원하는 것
가산점을 고려한 총 점수

### 내가 아는 것
입력값: 맞은 것은 1, 틀린것은 0으로 표기된 채점결과 배열

### 조건
1.  1번 문제가 맞는 경우에는 1점으로 계산한다.
2.   앞의 문제에 대해서는 답을 틀리다가 답이 맞는 처음 문제는 1점으로 계산한다.
3.  연속으로 문제의 답이 맞는 경우에서 두 번째 문제는 2점, 세 번째 문제는 3점, ..., K번째 문제는 K점으로 계산한다.

### 계획
기본 가산점을 0으로 할당해주고 맞출때마다 1점과 가산점씩 점수를 추가해준다. 그런다음 가산점도 올려준다. 반대로 틀릴때는 가산점을 0으로 리셋한다. 


