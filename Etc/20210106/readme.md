# 문제1
## 침몰하는 타이타닉(그리디)

### 원하는 것
승객 모두가 탈출하기 위한 구명보트의 최소개수

### 내가 아는 것
입력값: 보트에 탈 수 있는 최대무게 m, 승객들의 몸무게 배열 weights

### 조건
1. 승객의 수는 5명 이상 1000명 이하  
2. 70 <= m <= 250
3. 몸무게는 50이상 150이하
4. 구명보트는 2명 이하로만 탈 수 있다.

### 계획
몸무게를 오름차순 정렬한다. 만약 [0]번 인덱스와 마지막 인덱스의 합이 m이하라면 count +1, 두명이 탑승, 
아니라면 count+1, pop으로 마지막이 탑승하고 사람이 아무도 없어질 때까지 반복한다. 

### 반성 
--

# 문제2
## 증가수열 만들기(그리디)

### 원하는 것
최대 증가수열의 길이, 가져간 순서대로 왼쪽 끝에서 가져갔으면 ‘L', 오른쪽 끝에서 가져갔으면 ’R'를 써
간 문자열

### 내가 아는 것
입력값: 1부터 N까지의 모든 자연수로 구성된 길이 N의 수열 배열 numbers

### 조건
1. 마지막에 남은 값은 왼쪽 끝으로 생각한다. 
2. 증가수열 : 왼쪽 맨 끝 숫자 또는 오른쪽 맨 끝 숫자 중 하나를 가져와 나열하여 증가하는 숫자열 

### 계획
증가수열 배열과 방향 배열을 새로 만든다. 
반복을 시작한다. 증가수열의 마지막 인덱스가 numbers의 첫번째 인덱스와 마지막 인덱스보다 크다면 반복을 중단한다.  

만약 [0]번 인덱스가 증가수열 배열의 마지막 인덱스보다 작고 numbers의 마지막 인덱스보다 크다면 증가수열 배열에 push하고 방향배열에 'L'을 push한다. 

만약 마지막 인덱스가 증가수열 배열의 [0]번 인덱스보다 작고 numbers의 마지막 인덱스보다 크다면 증가수열 배열에 push하고 방향배열에 'R'을 push한다. 

증가수열이 비어있다면 [0]번 인덱스와 마지막 인덱스를 비교해서 하나를 넣어준다. 
 
### 반성 
if문을 줄이자!! 이 문제는 이분검색으로 풀면 조건문을 많이 줄일 수 있는 문제였다. 양 극에서 무언가 풀어가야 할 문제가 있다면 이분검색을 꼭 생각해보자. 
그리고 궅이 답을 하나에서 유추해 낼 수 있는걸 두개의 값을 구하려고 하지 말자. 이 문제에서도 L,R로 이루어진 문자열의 개수가 곧 답이었는데 쌩뚱맞게 새로운 배열을 만들어서 데이터를 낭비했다. 

# 문제3
## 역수열(그리디)

### 원하는 것
원래의 수열

### 내가 아는 것
입력값: n과 1부터 n까지의 수를 사용하여 이루어진 수열의 역수열 numbers

### 조건
1. 1부터 n까지 각각의 수 앞에 놓여 있는 자신보다 큰 수들의 개수를 수열로 표현한 것을 역수열이라 한다.  
2. 증가수열 : 왼쪽 맨 끝 숫자 또는 오른쪽 맨 끝 숫자 중 하나를 가져와 나열하여 증가하는 숫자열 

### 계획
새 결과배열을 만든다. 
i = numbers.length부터 1까지 for문으로 반복한다.

i가 0이면 그냥 결과배열.push 
아니면 numbers.splice(numbers[i - 1],0, i); 
 
### 반성 
원래 문제의 해설에서는 앞에서부터 시작해서 배열의 0의 개수로 구분래서 풀었는데 그것보다 내가 푼 뒤에서 부터 시작해서 하는 것이 반복과 조건문이 훨씬 절약되었다. 안에 조건문도 없앨려면 없앨 수 있기는 한데 명시성또한 고려해주어서 그냥 놔두었다. 알고리즘이 다는 아니니까 명시성도 생각을 하자. 
