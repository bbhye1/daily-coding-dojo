// 내가 원하는 것
// 실패율이 높은 스테이지부터 내림차순으로 스테이지 번호가 담긴 배열을 구하라

// 내가 아는 것
// 실패율: 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수
// 전체 스테이지 개수 : N
// 게임 이용자가 멈춰있는 스테이지 번호가 담긴 배열 stages

// 조건
// 스테이지의 개수 N은 1 이상 500 이하의 자연수이다.
// stages의 길이는 1 이상 200,000 이하이다.
// stages에는 1 이상 N + 1 이하의 자연수가 담겨있다.
// 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다.
// 단, N + 1 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다.
// 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다.
// 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다.

// 계획
// N번 순회 1 ~ N (인덱스 저장)
// N과 같은 수 / N보다 크거나 같은 요소 수 = 실패율
// 실패율 구하기 
// 실패율이 큰 수의 인덱스를 정렬한 배열 구하기. 


const getFailure = (N, stages) => {
  let arr = [];
  for (let i = 1; i <= N; i++) {
    const up = stages.filter((a) => a === i).length;
    const down = stages.filter((a) => a >= i).length;

    arr.push([up / down, i]);
  }

  const answer = arr.sort((a, b) => (b[0] - a[0]))
    .map(a => a[1]);

  return answer;
};

test('run', () => {
  expect(getFailure(5, [2, 1, 2, 6, 2, 4, 3, 3])).toEqual([3, 4, 2, 1, 5]);
  expect(getFailure(4, [4, 4, 4, 4, 4])).toEqual([4, 1, 2, 3]);
  expect(getFailure(4, [1, 1, 1, 1, 1])).toEqual([1, 2, 3, 4]);

});
