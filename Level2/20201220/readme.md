# 문제1 
## 프린터 문제 

1. 원하는 것
내가 요청한 작업이 진행이 되는 순번  
2. 내가 아는 것 
입력받는 값: 현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities,  내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지 알려주는 숫자   location
작업 수행 방식 : 
- 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.
- 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.
- 그렇지 않으면 J를 인쇄합니다.
3. 조건 
현재 대기목록에는 1개 이상 100개 이하의 문서가 있습니다.
인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요하다는 뜻입니다.
location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현합니다.
4. 계획
- 첫번째 계획: 배열을 순회하여 각 요소를 [중요도 , 처음인덱스] 형식으로 만든다.
  재귀를 돌려서 처음 요소보다 나머지 요소의 0번째 인덱스중 큰 것이 있다면 unshift로 추출후 push 아니면 배열을 그대로 반환한다. 요소들 중 1번째 인덱스가 location이랑 같은 것의 인덱스를 찾아 1을 더해 순번을 구한다. =>실패

- 두번째 계획: 반복문으로 동일하게 해본다. => 실패 

- 세번째 계획: 큐를 구현해서 큐에 남아있는 요소들을 이용해 반복적으로 enqueue와 decueue를 하고 순서가 정렬된 배열을 만들어내 값을 구한다. 

5. 반성 
재귀를 통해 푸는 방법이나 똑같은 내용을 반복문으로만 푸는 방법이나 둘다 진행하면서 계속 바뀌는 것을 해결해 주지 못했다. 
그래서 Queue를 구현해서 구현해냈다.  일단 기본적인 Queue를 이해하는것이 중요한 것 같다. 

다른 분의 풀이 
```javascript
function solution(priorities, location) {
    var list = priorities.map((t,i)=>({
        my : i === location,    //처음부터 인덱스가 맞는지 여부를 확인 후 진행
        val : t
    }));
    var count = 0;        
    while(true){
        var cur = list.shift();        
        if(list.some(t=> t.val > cur.val )){
            list.push(cur);                        
        }
        else{            
            count++;   // 일이 처리되는 순서 
            if(cur.my) return count;
        }
    }
}
```
