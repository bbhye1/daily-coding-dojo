문제1 소수찾기
한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다.
각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요.

1. 원하는 것
최소값과 최대값을 찾아 "최소값 최대값" 형태의 문자열로 반환하기 
2. 내가 아는 것 
입력받는 값: 숫자로 이루어진 문자열
3. 조건 
numbers는  0~9까지 숫자만으로 이루어진 길이 1 이상 7 이하인 문자열. 최소 0 최대 9999999
numbers가 013이라면 사용할 수 ㅣ있는 숫자가 0, 1, 3 라는의미  
11과 011은 같은 숫자로 취급합니다.
4. 계획
numbers의 length만큼 반복문을 돌려서 만들 수 있는 개수를 모두 만들기 재귀? 반복의 반복의 반복의 반복?  
일단 숫자를 조합해서 만들 수 있는 모든 조합 다 만들기 (재귀이용)
그 후에 결과를 반복문을 통해 소수인지 가려내기 
5. 반성 
아예 순열, 재귀로 푸는 법의 감을 못잡아서 검색을 통해 풀이 방법을 익히는 문제였다. 그래서 계획이 너무 두루뭉술하다. 다음 완전탐색문제를 하나 더 풀면서 더 익혀보자. 

문제2 과자
책상 위에 놓인 과자를 많이 먹은 동우는 남은 과자를 친구에게 선물하기로 하였습니다.
처음 먹는 과자를 제외하고, 새로 먹는 과자는 이전에 먹는 과자보다 맛이 좋아야 합니다. (맛의 정도는 자연수로 표시됩니다.)
위의 규칙을 지키면서 가능한 많은 과자를 먹어야 합니다.
책상 위에 놓인 과자 목록 cookies와 과자를 먹을 수 있는 방법의 순서 k가 주어질 때, 과자를 먹을 수 있는 방법을 사전순으로 나열하고 k번째 순서의 과자의 목록을 반환하는 함수를 완성해 주세요.

1. 원하는 것
과자를 먹을 수 있는 방법을 사전순으로 나열히고 그 중 k번째 
2. 내가 아는 것 
입력받는 값: 책상 위에 놓인 과자 목록 cookies, 과자를 먹을 수 있는 방법의 순서 k
3. 조건 
처음 먹는 과자를 제외하고 새로먹는 과자는 이전과자보다 맛이 좋아야한다. -> 세개의 숫자들은 모두 오름차순으로 되어있다. 
가능한 많은 과자를 먹어한다. -> 남은 과자들중 먹을 수 있는 과자들보다 큰수가 남아있으면 안된다. 
책상 위에 놓인 과자 목록 cookies 개수 : 100이하의 자연수
책상 위에 놓인 과자 크기 : 10,000 이하의 자연수
k번째 순서로 과자를 먹는 방법이 있는 경우만 입력으로 주어진다. => 없을경우 예외처리 필요 없음
4. 계획
순열과 재귀를 이용해서 만들 수 있는 모든 배열을 만든다. 
쿠키들의 개수만큼 순회하여 하나씩 숫자를 고르고 나머지 숫자중에서 숫자를 골라 배열을 완성한다. 
배열을 오름차순으로 sort한 결과가 배열과 같은것을 골라서 result 배열에 넣고 다시 정렬한다. 
5. 반성 
비슷한 순열 재귀로 풀 수 있을것같아서 저번 코딩테스트때 문제 다시 풀어보았다. 
계획이 정확히 머릿속에 정리되지 않은 상태에서 풀어서 푸는 데 거의 4시간이 소요됬다. 
이제 순열재귀 30% 이해한듯. 순열은 찾아보면 그냥 외워두라는 말이 나온다. 세우고 쓰다보면 사용능력 100% 되겠지.
sort된 것과 비교해서 오름차순인지 구분하는 로직을 나중에 또 for문을 돌며 찾아주는 것보다 처음에 해주는 것이 반복문을 절약하는 방법이지 않을까 싶어서 수정하다가 실패했다.
아직 비슷한 유형의 문제를 더 풀어봐야할 듯 하다. 