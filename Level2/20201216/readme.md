문제1
카펫 - 완전탐색
Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다.
Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다.
Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.

1. 원하는 것
카펫의 가로와 세로를 담은 배열 [가로, 세로] 
2. 내가 아는 것 
입력받는 값: 갈색 격자의 개수, 노란색 격자의 개수
카펫은 중앙이 노란색이고 테두리 1줄이 갈색이다.
3. 조건 
갈색 격자의 수는 8 이상 5000 이하의 자연수 
노란색 격자의 수는 1이상 2000000이하의 자연수 
카펫의 가로길이 >= 세로길이  -> 큰수가 가로다 
4. 계획
갈색에서 각 모서리의 4개를 뺀 개수가 노란색 네모의 변의 합
노랑이 24개라면 만들수 있는 직사각형의 가로+세로는  1+24 2+12 3+8 4+6 => 약수의 집합으로 구성됨
(갈색 수 -4) / 2 = 노랑의 가로 + 노랑의 세로 
구하는 값: [노랑의 가로+2, 노랑의 세로+2] 
노랑의 약수 배열을 순환해서 pop과 shift를 이용해 (갈색 수 -4) / 2 와 동일한 값을 얻어낸다. 
단 약수배열의 길이가 홀수라면 마지막 약수의 노랑네모의 가로+세로 값은 마지막 약수 값 + 마지막 약수 값
그중 큰것이 가로 작은것이 세로
5. 반성 
처음 풀이를 보니 참 복잡하게도 풀었다.
반복문으로 약수를 찾고 또 반복문을 통해 확인하는 과정이 불필요하다고 생각해서 하나의 반복문으로 압축시켜 리팩토링했다. 그랬더니 맨처음 yellow가 1일 때 발생하는 예외상황을 예외상황으로 처리하지 않아도 되었다. 그 말은 처음부터 예외처리는 필요하지 않았다는 것. 
이 문제에서의 핵심은 brown과 yellow의 상관관계이다.
다른 분의 풀이들을 살펴보다 전체 직사각형의 가로 + 세로 = brown + yelllow의 약수들로 구성되어 있다는걸 깨달았다. 그러니 [yellowWidth + 2, yellowHeight + 2] 이렇게 구하지 말고 처음부터 전체의 가로세로 길이를 구하는 것이 더 깔끔하다. 
문제를 풀때 인수와 결과값의 관계를 살펴보는 것도 중요하다는 걸 깨달았다. 
6. 완전탐색 
이 문제의 키워드는 완전탐색이다. 
완전탐색이란 모든 경우의 수를 전부 찾아서 답을 찾는 알고리즘으로 가능한 한 모든 경우의 수를 모두 해보아서 가장 확실하지만 가장 오래걸리는 탐색기법이다. 
- Brute Force : for문과 if문을 통해 처음부터 끝까지 탐색하는 기법 (오늘 풀어본 문제 유형)
- 비트 마스트 : 이진수 표현을 자료구조로 쓰는 기법 (AND, OR, XOR, SHIFT, NOT)
- 재귀함수
- 순열: 서로 다른 n개의 원소에서 r개의 중복을 허용하지 않고 순서대로 늘어놓은 수
- BFS(너비우선탐색), DFS(깊이우선탐색).

